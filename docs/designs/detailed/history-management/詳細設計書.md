# å±¥æ­´ãƒ¡ãƒ¢æ©Ÿèƒ½ è©³ç´°è¨­è¨ˆæ›¸

## 1. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±

| é …ç›® | å†…å®¹ |
|------|------|
| ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆID | DET-NOTE-001 |
| æ©Ÿèƒ½ID | F-025 |
| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | 1.0.0 |
| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | ãƒ‰ãƒ©ãƒ•ãƒˆ |
| ä½œæˆæ—¥ | 2026-01-11 |
| æœ€çµ‚æ›´æ–°æ—¥ | 2026-01-11 |
| ä½œæˆè€… | detailed-design-writer |
| é–¢é€£æ–‡æ›¸ | REQ-CLI-003_MML-Syntax-Extension.md (v1.0.0)<br>BASIC-CLI-003_MML-Syntax-Extension.md (v1.0.0) |

---

## 2. æ©Ÿèƒ½æ¦‚è¦

### 2.1 ç›®çš„

MMLæ¼”å¥å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ã§ãã‚‹ã‚ˆã†ã«ã—ã€å¾Œã§å±¥æ­´ã‚’è¦‹è¿”ã—ãŸã¨ãã«ã€Œä½•ã®æ›²ã‹ã€ã€Œã©ã†ã„ã†æ„å›³ã§ä½œã£ãŸã‹ã€ã‚’æ€ã„å‡ºã—ã‚„ã™ãã™ã‚‹ã€‚

### 2.2 èƒŒæ™¯

ç¾åœ¨ã®å±¥æ­´æ©Ÿèƒ½ã§ã¯ã€MMLæ–‡å­—åˆ—ã€æ³¢å½¢ã€BPMã€éŸ³é‡ãªã©ã®æŠ€è¡“çš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã¿ãŒè¨˜éŒ²ã•ã‚Œã‚‹ãŸã‚ã€å¾Œã§å±¥æ­´ã‚’è¦‹è¿”ã—ãŸã¨ãã«ã€Œã“ã‚Œã¯ä½•ã®æ›²ã ã£ãŸã‹ã€ãŒåˆ†ã‹ã‚‰ãªã„ã€‚ç‰¹ã«ä»¥ä¸‹ã®ã‚ˆã†ãªèª²é¡ŒãŒã‚ã‚‹ï¼š

- çŸ­ã„MMLæ–‡å­—åˆ—ï¼ˆä¾‹: `CDEFGAB`ï¼‰ã§ã¯å†…å®¹ãŒæ¨æ¸¬ã§ããªã„
- å®Ÿé¨“çš„ãªæ¼”å¥ãŒå¤šæ•°è¨˜éŒ²ã•ã‚Œã‚‹ã¨ã€ã©ã‚ŒãŒé‡è¦ã‹åˆ†ã‹ã‚‰ãªã„
- å¾Œã§å†åˆ©ç”¨ã—ãŸã„æ¼”å¥ã‚’è¦‹ã¤ã‘ã«ãã„

### 2.3 ã‚¹ã‚³ãƒ¼ãƒ—

#### å¯¾è±¡ç¯„å›²
- `play` ã‚³ãƒãƒ³ãƒ‰ã« `--note` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
- å±¥æ­´DBã« `note` ã‚«ãƒ©ãƒ ã‚’è¿½åŠ ï¼ˆv1â†’v2ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
- `history` ã‚³ãƒãƒ³ãƒ‰ã®è¡¨ç¤ºã«ãƒ¡ãƒ¢åˆ—ã‚’è¿½åŠ 
- ãƒ¡ãƒ¢ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæœ€å¤§500æ–‡å­—ã€UTF-8å¯¾å¿œï¼‰

#### å¯¾è±¡å¤–
- ãƒ¡ãƒ¢ã®æ¤œç´¢æ©Ÿèƒ½ï¼ˆPhase 3.0ã§æ¤œè¨ï¼‰
- ãƒ¡ãƒ¢ã®ç·¨é›†æ©Ÿèƒ½ï¼ˆPhase 3.0ã§æ¤œè¨ï¼‰
- ãƒ¡ãƒ¢ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆPhase 3.0ã§æ¤œè¨ï¼‰
- å±¥æ­´IDã‹ã‚‰ã®ãƒ¡ãƒ¢å–å¾—APIï¼ˆç¾æ™‚ç‚¹ã§ã¯ä¸è¦ï¼‰

---

## 3. è©³ç´°ä»•æ§˜

### 3.1 CLIã‚ªãƒ—ã‚·ãƒ§ãƒ³ä»•æ§˜

#### 3.1.1 `--note` ã‚ªãƒ—ã‚·ãƒ§ãƒ³

**è¿½åŠ å…ˆ**: `play` ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰

**å®šç¾©**:
```rust
// src/cli/args.rs

#[derive(Args, Debug)]
pub struct PlayArgs {
    // ... æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ...
    
    /// å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰
    #[arg(
        long,
        help = "å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ï¼ˆæœ€å¤§500æ–‡å­—ã€UTF-8å¯¾å¿œï¼‰"
    )]
    pub note: Option<String>,
}
```

**ä»•æ§˜**:

| é …ç›® | å†…å®¹ |
|------|------|
| ã‚ªãƒ—ã‚·ãƒ§ãƒ³å | `--note` |
| çŸ­ç¸®å½¢ | ãªã— |
| å‹ | `Option<String>` |
| ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ | `None` |
| å¿…é ˆ | ã„ã„ãˆ |
| æœ€å¤§é•· | 500æ–‡å­— |
| æ–‡å­—ã‚³ãƒ¼ãƒ‰ | UTF-8ï¼ˆçµµæ–‡å­—å¯¾å¿œï¼‰ |
| ä½µç”¨å¯èƒ½ã‚ªãƒ—ã‚·ãƒ§ãƒ³ | `--loop-play`, `--metronome`, `--waveform`, `--volume` |

**ä½¿ç”¨ä¾‹**:
```bash
# åŸºæœ¬çš„ãªä½¿ç”¨
sine-mml play "CDEFGAB" --note "My first melody"

# æ—¥æœ¬èªã¨UTF-8æ–‡å­—
sine-mml play "CDEFGAB" --note "æœ€åˆã®ãƒ¡ãƒ­ãƒ‡ã‚£ ğŸµ"

# ãƒ«ãƒ¼ãƒ—å†ç”Ÿã¨ä½µç”¨
sine-mml play "[CDEF]4" --loop-play --note "Loop test"

# ãƒ¡ãƒ¢ãªã—ï¼ˆå¾“æ¥é€šã‚Šï¼‰
sine-mml play "CDEFGAB"

# ç©ºæ–‡å­—åˆ—ï¼ˆä¿å­˜ã•ã‚Œã‚‹ï¼‰
sine-mml play "CDEFGAB" --note ""
```

#### 3.1.2 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»•æ§˜

**ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: CLIãƒãƒ³ãƒ‰ãƒ©ãƒ¼å†…ï¼ˆ`play_handler`ï¼‰

**ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°**:
```rust
// src/cli/handlers.rs

/// ãƒ¡ãƒ¢ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
///
/// # Arguments
/// * `note` - ãƒ¡ãƒ¢æ–‡å­—åˆ—
///
/// # Returns
/// * `Ok(())` - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ
/// * `Err(anyhow::Error)` - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—
fn validate_note(note: &str) -> Result<()> {
    if note.chars().count() > 500 {
        bail!("[CLI-E010] ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: {}æ–‡å­—ï¼‰", note.chars().count());
    }
    Ok(())
}
```

**ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«**:

| ãƒ«ãƒ¼ãƒ«ID | æ¡ä»¶ | ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ |
|---------|------|----------------|
| BR-058 | ãƒ¡ãƒ¢ã¯ä»»æ„ï¼ˆæŒ‡å®šã—ãªãã¦ã‚‚å‹•ä½œã™ã‚‹ï¼‰ | - |
| BR-059 | ãƒ¡ãƒ¢ã®æœ€å¤§é•·ã¯500æ–‡å­— | `[CLI-E010] ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: XXXæ–‡å­—ï¼‰` |
| BR-060 | UTF-8æ–‡å­—åˆ—ï¼ˆçµµæ–‡å­—ã‚‚å¯ï¼‰ | - |
| BR-061 | `--loop-play` ã¨ä½µç”¨å¯èƒ½ | - |

**æ³¨æ„äº‹é …**:
- æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ãƒˆã¯ `str::chars().count()` ã‚’ä½¿ç”¨ï¼ˆãƒã‚¤ãƒˆæ•°ã§ã¯ãªãæ–‡å­—æ•°ï¼‰
- ç©ºæ–‡å­—åˆ—ï¼ˆ`""`ï¼‰ã¯è¨±å¯ã•ã‚Œã‚‹ï¼ˆDBã«ã¯ç©ºæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜ï¼‰
- `None`ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³æœªæŒ‡å®šï¼‰ã®å ´åˆã¯DBã«`NULL`ã¨ã—ã¦ä¿å­˜

---

### 3.2 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å¤‰æ›´

#### 3.2.1 `HistoryEntry` æ§‹é€ ä½“

**å¤‰æ›´å‰**:
```rust
// src/db/history.rs

pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub created_at: DateTime<Utc>,
}
```

**å¤‰æ›´å¾Œ**:
```rust
// src/db/history.rs

pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub note: Option<String>,  // è¿½åŠ 
    pub created_at: DateTime<Utc>,
}
```

**ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»•æ§˜**:

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ | å‹ | NULLè¨±å¯ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ |
|-----------|-----|---------|----------|------|
| `note` | `Option<String>` | â—‹ | `None` | å±¥æ­´ãƒ¡ãƒ¢ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰ |

#### 3.2.2 `HistoryEntry::new` ãƒ¡ã‚½ãƒƒãƒ‰

**å¤‰æ›´å‰**:
```rust
impl HistoryEntry {
    pub fn new(mml: String, waveform: Waveform, volume: f32, bpm: u16) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            created_at: Utc::now(),
        }
    }
}
```

**å¤‰æ›´å¾Œ**:
```rust
impl HistoryEntry {
    pub fn new(mml: String, waveform: Waveform, volume: f32, bpm: u16, note: Option<String>) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            note,
            created_at: Utc::now(),
        }
    }
}
```

**å¤‰æ›´ç‚¹**:
- `note: Option<String>` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
- æ§‹é€ ä½“åˆæœŸåŒ–æ™‚ã« `note` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¨­å®š

---

### 3.3 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´

#### 3.3.1 ã‚¹ã‚­ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³

**å¤‰æ›´å‰**:
```rust
// src/db/schema.rs
pub const CURRENT_VERSION: i64 = 1;
```

**å¤‰æ›´å¾Œ**:
```rust
// src/db/schema.rs
pub const CURRENT_VERSION: i64 = 2;  // v1 â†’ v2
```

#### 3.3.2 ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©

**å¤‰æ›´å‰ï¼ˆv1ï¼‰**:
```sql
CREATE TABLE IF NOT EXISTS history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    mml TEXT NOT NULL,
    waveform TEXT NOT NULL CHECK(waveform IN ('sine', 'sawtooth', 'square')),
    volume REAL NOT NULL CHECK(volume >= 0.0 AND volume <= 1.0),
    bpm INTEGER NOT NULL CHECK(bpm >= 30 AND bpm <= 300),
    created_at TEXT NOT NULL
);
```

**å¤‰æ›´å¾Œï¼ˆv2ï¼‰**:
```sql
CREATE TABLE IF NOT EXISTS history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    mml TEXT NOT NULL,
    waveform TEXT NOT NULL CHECK(waveform IN ('sine', 'sawtooth', 'square')),
    volume REAL NOT NULL CHECK(volume >= 0.0 AND volume <= 1.0),
    bpm INTEGER NOT NULL CHECK(bpm >= 30 AND bpm <= 300),
    note TEXT NULL CHECK(length(note) <= 500),  -- è¿½åŠ 
    created_at TEXT NOT NULL
);
```

**è¿½åŠ ã‚«ãƒ©ãƒ ä»•æ§˜**:

| ã‚«ãƒ©ãƒ å | å‹ | NULL | CHECKåˆ¶ç´„ | èª¬æ˜ |
|---------|-----|------|----------|------|
| `note` | TEXT | â—‹ | `length(note) <= 500` | å±¥æ­´ãƒ¡ãƒ¢ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰ |

**æ³¨æ„äº‹é …**:
- `NULL` è¨±å¯ã«ã‚ˆã‚Šã€æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã‚’ä¿ã¤
- `CHECK` åˆ¶ç´„ã«ã‚ˆã‚Šã€DBå±¤ã§ã‚‚500æ–‡å­—åˆ¶é™ã‚’å¼·åˆ¶
- `length()` é–¢æ•°ã¯æ–‡å­—æ•°ï¼ˆãƒã‚¤ãƒˆæ•°ã§ã¯ãªã„ï¼‰ã‚’ã‚«ã‚¦ãƒ³ãƒˆ

#### 3.3.3 ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†

**ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°**:
```rust
// src/db/schema.rs

/// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
///
/// # Arguments
/// * `conn` - SQLiteæ¥ç¶š
///
/// # Returns
/// * `Ok(())` - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ
/// * `Err(DbError)` - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—
pub fn migrate(conn: &Connection) -> Result<(), DbError> {
    // 1. ã‚¹ã‚­ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä½œæˆï¼ˆåˆå›ã®ã¿ï¼‰
    conn.execute(
        "CREATE TABLE IF NOT EXISTS schema_version (
            version INTEGER PRIMARY KEY
        )",
        [],
    )?;
    
    // 2. ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯1ã¨ã¿ãªã™ï¼‰
    let version: i64 = conn
        .query_row("SELECT version FROM schema_version", [], |row| row.get(0))
        .unwrap_or(1);
    
    // 3. v1 â†’ v2 ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    if version < 2 {
        conn.execute("ALTER TABLE history ADD COLUMN note TEXT NULL", [])?;
        
        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°
        if version == 1 {
            conn.execute("UPDATE schema_version SET version = 2", [])?;
        } else {
            conn.execute("INSERT INTO schema_version (version) VALUES (2)", [])?;
        }
    }
    
    Ok(())
}
```

**ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚°**:
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ï¼ˆ`Database::init()` å†…ï¼‰
- `initialize()` é–¢æ•°ã®å¾Œã« `migrate()` ã‚’å‘¼ã³å‡ºã™

**å¤‰æ›´å¾Œã® `initialize()` é–¢æ•°**:
```rust
// src/db/schema.rs

pub fn initialize(conn: &Connection) -> Result<(), DbError> {
    // æ—¢å­˜ã®ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆå‡¦ç†...
    
    // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    migrate(conn)?;
    
    Ok(())
}
```

---

### 3.4 å±¥æ­´ä¿å­˜å‡¦ç†ã®å¤‰æ›´

#### 3.4.1 `play_handler` ã®å¤‰æ›´

**å¤‰æ›´ç®‡æ‰€**: `src/cli/handlers.rs` ã® `play_handler` é–¢æ•°

**å¤‰æ›´å‰**:
```rust
let entry = db::HistoryEntry::new(mml_string.clone(), db_waveform, args.volume, bpm_u16);
```

**å¤‰æ›´å¾Œ**:
```rust
// ãƒ¡ãƒ¢ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
if let Some(ref note) = args.note {
    validate_note(note)?;
}

let entry = db::HistoryEntry::new(
    mml_string.clone(),
    db_waveform,
    args.volume,
    bpm_u16,
    args.note.clone(),  // è¿½åŠ 
);
```

**å‡¦ç†ãƒ•ãƒ­ãƒ¼**:
1. `args.note` ãŒ `Some` ã®å ´åˆã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
2. ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã€`HistoryEntry::new` ã« `note` ã‚’æ¸¡ã™
3. DBä¿å­˜å‡¦ç†ã¯æ—¢å­˜ã®ã¾ã¾ï¼ˆ`save` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ `note` ã‚’å‡¦ç†ï¼‰

#### 3.4.2 `Database::save` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
// src/db/mod.rs (ã¾ãŸã¯ history.rs)

pub fn save(&self, entry: &HistoryEntry) -> Result<i64, DbError> {
    let conn = self.conn.lock().unwrap();
    conn.execute(
        "INSERT INTO history (mml, waveform, volume, bpm, created_at)
         VALUES (?1, ?2, ?3, ?4, ?5)",
        (
            &entry.mml,
            entry.waveform.as_str(),
            entry.volume,
            entry.bpm,
            entry.created_at.to_rfc3339(),
        ),
    )?;
    Ok(conn.last_insert_rowid())
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn save(&self, entry: &HistoryEntry) -> Result<i64, DbError> {
    let conn = self.conn.lock().unwrap();
    conn.execute(
        "INSERT INTO history (mml, waveform, volume, bpm, note, created_at)
         VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
        (
            &entry.mml,
            entry.waveform.as_str(),
            entry.volume,
            entry.bpm,
            entry.note.as_deref(),  // Option<String> â†’ Option<&str>
            entry.created_at.to_rfc3339(),
        ),
    )?;
    Ok(conn.last_insert_rowid())
}
```

**å¤‰æ›´ç‚¹**:
- SQLæ–‡ã« `note` ã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
- `entry.note.as_deref()` ã§ `Option<String>` ã‚’ `Option<&str>` ã«å¤‰æ›
- `None` ã®å ´åˆã¯ `NULL` ã¨ã—ã¦ä¿å­˜ã•ã‚Œã‚‹

---

### 3.5 å±¥æ­´è¡¨ç¤ºã®å¤‰æ›´

#### 3.5.1 `history_handler` ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
// src/cli/handlers.rs

pub fn history_handler() -> Result<()> {
    let db = Database::init()?;
    let entries = db.get_all()?;
    
    if entries.is_empty() {
        println!("å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
        return Ok(());
    }
    
    let mut table = Table::new();
    table.set_header(vec![
        "ID", "Created At", "MML", "Waveform", "BPM", "Volume"
    ]);
    
    for entry in entries {
        table.add_row(vec![
            entry.id.unwrap().to_string(),
            entry.created_at.format("%Y-%m-%d %H:%M:%S").to_string(),
            entry.mml,
            entry.waveform.as_str().to_string(),
            entry.bpm.to_string(),
            entry.volume.to_string(),
        ]);
    }
    
    println!("{table}");
    Ok(())
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn history_handler() -> Result<()> {
    let db = Database::init()?;
    let entries = db.get_all()?;
    
    if entries.is_empty() {
        println!("å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
        return Ok(());
    }
    
    let mut table = Table::new();
    table.set_header(vec![
        "ID", "Created At", "MML", "Waveform", "BPM", "Volume", "Note"  // è¿½åŠ 
    ]);
    
    for entry in entries {
        table.add_row(vec![
            entry.id.unwrap().to_string(),
            entry.created_at.format("%Y-%m-%d %H:%M:%S").to_string(),
            entry.mml,
            entry.waveform.as_str().to_string(),
            entry.bpm.to_string(),
            entry.volume.to_string(),
            entry.note.unwrap_or_else(|| "-".to_string()),  // è¿½åŠ 
        ]);
    }
    
    println!("{table}");
    Ok(())
}
```

**å¤‰æ›´ç‚¹**:
- ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã« `"Note"` åˆ—ã‚’è¿½åŠ 
- å„è¡Œã« `entry.note` ã‚’è¿½åŠ 
- `None` ã®å ´åˆã¯ `"-"` ã¨è¡¨ç¤ºï¼ˆç©ºæ¬„ã«ã—ãªã„ï¼‰

**è¡¨ç¤ºä¾‹**:
```
ID | Created At          | MML          | Waveform | BPM | Volume | Note
---|---------------------|--------------|----------|-----|--------|------------------
5  | 2026-01-11 10:30:00 | CDEFGAB      | sine     | 120 | 0.5    | My first melody
4  | 2026-01-09 14:20:00 | [CDEF]4      | square   | 140 | 0.7    | Loop test
3  | 2026-01-08 09:15:00 | O5 T180 CRCR | sawtooth | 180 | 0.8    | -
```

#### 3.5.2 `Database::get_all` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
pub fn get_all(&self) -> Result<Vec<HistoryEntry>, DbError> {
    let conn = self.conn.lock().unwrap();
    let mut stmt = conn.prepare(
        "SELECT id, mml, waveform, volume, bpm, created_at
         FROM history
         ORDER BY created_at DESC"
    )?;
    
    let entries = stmt.query_map([], |row| {
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform: row.get::<_, String>(2)?.parse().unwrap(),
            volume: row.get(3)?,
            bpm: row.get(4)?,
            created_at: DateTime::parse_from_rfc3339(&row.get::<_, String>(5)?)
                .unwrap()
                .with_timezone(&Utc),
        })
    })?
    .collect::<Result<Vec<_>, _>>()?;
    
    Ok(entries)
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn get_all(&self) -> Result<Vec<HistoryEntry>, DbError> {
    let conn = self.conn.lock().unwrap();
    let mut stmt = conn.prepare(
        "SELECT id, mml, waveform, volume, bpm, note, created_at
         FROM history
         ORDER BY created_at DESC"
    )?;
    
    let entries = stmt.query_map([], |row| {
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform: row.get::<_, String>(2)?.parse().unwrap(),
            volume: row.get(3)?,
            bpm: row.get(4)?,
            note: row.get(5)?,  // è¿½åŠ 
            created_at: DateTime::parse_from_rfc3339(&row.get::<_, String>(6)?)
                .unwrap()
                .with_timezone(&Utc),
        })
    })?
    .collect::<Result<Vec<_>, _>>()?;
    
    Ok(entries)
}
```

**å¤‰æ›´ç‚¹**:
- SQLæ–‡ã« `note` ã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
- `row.get(5)?` ã§ `note` ã‚’å–å¾—ï¼ˆ`Option<String>` ã¨ã—ã¦ï¼‰
- `created_at` ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ 5 â†’ 6 ã«å¤‰æ›´

---

## 4. å‡¦ç†ãƒ•ãƒ­ãƒ¼

### 4.1 ãƒ¡ãƒ¢ä»˜ãæ¼”å¥ä¿å­˜ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    autonumber
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant CLI as CLI Args Parser
    participant Handler as PlayHandler
    participant Validator as validate_note
    participant DB as Database
    participant SQLite as SQLite

    User->>CLI: play "CDEFGAB" --note "My melody"
    CLI->>Handler: PlayArgs { note: Some("My melody"), ... }
    
    Handler->>Handler: parse_mml("CDEFGAB")
    Handler->>Handler: synthesize_audio()
    
    alt note ãŒ Some ã®å ´åˆ
        Handler->>Validator: validate_note("My melody")
        
        alt 500æ–‡å­—ä»¥å†…
            Validator-->>Handler: Ok(())
        else 500æ–‡å­—è¶…é
            Validator-->>Handler: Err([CLI-E010])
            Handler-->>User: Error: ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„
        end
    end
    
    Handler->>Handler: create HistoryEntry { note: Some("My melody"), ... }
    Handler->>DB: save(entry)
    
    DB->>SQLite: INSERT INTO history (..., note, ...)
    SQLite-->>DB: history_id = 42
    DB-->>Handler: Ok(42)
    
    Handler->>User: âœ“ å±¥æ­´ID: 42ï¼ˆãƒ¡ãƒ¢: My melodyï¼‰
    Handler->>Handler: play_audio()
```

### 4.2 ãƒ¡ãƒ¢ãªã—æ¼”å¥ä¿å­˜ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    autonumber
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant CLI as CLI Args Parser
    participant Handler as PlayHandler
    participant DB as Database
    participant SQLite as SQLite

    User->>CLI: play "CDEFGAB"
    CLI->>Handler: PlayArgs { note: None, ... }
    
    Handler->>Handler: parse_mml("CDEFGAB")
    Handler->>Handler: synthesize_audio()
    
    Note over Handler: note ãŒ None ã®ãŸã‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚­ãƒƒãƒ—
    
    Handler->>Handler: create HistoryEntry { note: None, ... }
    Handler->>DB: save(entry)
    
    DB->>SQLite: INSERT INTO history (..., note=NULL, ...)
    SQLite-->>DB: history_id = 43
    DB-->>Handler: Ok(43)
    
    Handler->>User: âœ“ å±¥æ­´ID: 43
    Handler->>Handler: play_audio()
```

### 4.3 å±¥æ­´è¡¨ç¤ºãƒ•ãƒ­ãƒ¼ï¼ˆãƒ¡ãƒ¢åˆ—è¿½åŠ ï¼‰

```mermaid
sequenceDiagram
    autonumber
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant Handler as HistoryHandler
    participant DB as Database
    participant SQLite as SQLite
    participant Table as comfy-table

    User->>Handler: history
    Handler->>DB: get_all()
    
    DB->>SQLite: SELECT id, mml, ..., note, created_at FROM history
    SQLite-->>DB: [entry1, entry2, entry3]
    DB-->>Handler: Vec<HistoryEntry>
    
    Handler->>Table: set_header(["ID", ..., "Note"])
    
    loop å„ã‚¨ãƒ³ãƒˆãƒªãƒ¼
        alt note ãŒ Some
            Handler->>Table: add_row([..., note])
        else note ãŒ None
            Handler->>Table: add_row([..., "-"])
        end
    end
    
    Table-->>Handler: formatted_table
    Handler->>User: è¡¨ç¤º
    
    Note over User: ID | ... | Note<br>5  | ... | My melody<br>4  | ... | -
```

### 4.4 DBãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ­ãƒ¼ï¼ˆv1â†’v2ï¼‰

```mermaid
sequenceDiagram
    autonumber
    participant App as ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
    participant DB as Database::init()
    participant Schema as schema.rs
    participant SQLite as SQLite

    App->>DB: åˆæœŸåŒ–
    DB->>Schema: initialize(conn)
    Schema->>Schema: create tables...
    Schema->>Schema: migrate(conn)
    
    Schema->>SQLite: CREATE TABLE IF NOT EXISTS schema_version
    Schema->>SQLite: SELECT version FROM schema_version
    
    alt ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ãŒç©º
        SQLite-->>Schema: Error (no rows)
        Note right of Schema: version = 1 ã¨ã¿ãªã™
    else ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå­˜åœ¨
        SQLite-->>Schema: version = 1
    end
    
    alt version < 2
        Note over Schema: v1 â†’ v2 ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        Schema->>SQLite: BEGIN TRANSACTION
        Schema->>SQLite: ALTER TABLE history ADD COLUMN note TEXT NULL
        
        alt version == 1
            Schema->>SQLite: UPDATE schema_version SET version = 2
        else åˆå›ï¼ˆversion == 0ï¼‰
            Schema->>SQLite: INSERT INTO schema_version (version) VALUES (2)
        end
        
        Schema->>SQLite: COMMIT
        SQLite-->>Schema: æˆåŠŸ
    else version >= 2
        Note right of Schema: ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸è¦
    end
    
    Schema-->>DB: ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
    DB-->>App: åˆæœŸåŒ–å®Œäº†
```

---

## 5. ç”»é¢å¤‰æ›´ï¼ˆå±¥æ­´è¡¨ç¤ºï¼‰

### 5.1 å¤‰æ›´å‰ã®å±¥æ­´è¡¨ç¤º

```
ID | Created At          | MML          | Waveform | BPM | Volume
---|---------------------|--------------|----------|-----|--------
5  | 2026-01-11 10:30:00 | CDEFGAB      | sine     | 120 | 0.5
4  | 2026-01-09 14:20:00 | [CDEF]4      | square   | 140 | 0.7
3  | 2026-01-08 09:15:00 | O5 T180 CRCR | sawtooth | 180 | 0.8
```

### 5.2 å¤‰æ›´å¾Œã®å±¥æ­´è¡¨ç¤º

```
ID | Created At          | MML          | Waveform | BPM | Volume | Note
---|---------------------|--------------|----------|-----|--------|------------------
5  | 2026-01-11 10:30:00 | CDEFGAB      | sine     | 120 | 0.5    | My first melody
4  | 2026-01-09 14:20:00 | [CDEF]4      | square   | 140 | 0.7    | Loop test
3  | 2026-01-08 09:15:00 | O5 T180 CRCR | sawtooth | 180 | 0.8    | -
```

### 5.3 è¡¨ç¤ºä»•æ§˜

| é …ç›® | ä»•æ§˜ |
|------|------|
| åˆ—å | `Note` |
| è¡¨ç¤ºä½ç½® | æœ€å³åˆ—ï¼ˆ`Volume` ã®å³ï¼‰ |
| ãƒ¡ãƒ¢ã‚ã‚Š | ãƒ¡ãƒ¢å†…å®¹ã‚’ãã®ã¾ã¾è¡¨ç¤º |
| ãƒ¡ãƒ¢ãªã—ï¼ˆ`NULL`ï¼‰ | `"-"` ã¨è¡¨ç¤º |
| ç©ºæ–‡å­—åˆ—ï¼ˆ`""`ï¼‰ | ç©ºæ¬„ã¨ã—ã¦è¡¨ç¤º |
| é•·ã„ãƒ¡ãƒ¢ | åˆ‡ã‚Šè©°ã‚ãªã—ï¼ˆå…¨æ–‡è¡¨ç¤ºï¼‰ |

**æ³¨æ„äº‹é …**:
- ãƒ¡ãƒ¢ãŒé•·ã„å ´åˆã€ãƒ†ãƒ¼ãƒ–ãƒ«ã®å¹…ãŒåºƒãŒã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
- `comfy-table` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã«å¾“ã†ï¼ˆè‡ªå‹•æŠ˜ã‚Šè¿”ã—ï¼‰
- ã‚¿ãƒ¼ãƒŸãƒŠãƒ«å¹…ã‚’è¶…ãˆã‚‹å ´åˆã¯æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒå¿…è¦

---

## 6. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### 6.1 ã‚¨ãƒ©ãƒ¼ä¸€è¦§

| ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ | æ¡ä»¶ | ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ | HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆè©²å½“ãªã—ï¼‰ |
|------------|------|-----------|--------------------------|
| CLI-E010 | ãƒ¡ãƒ¢ãŒ500æ–‡å­—è¶…é | `ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: XXXæ–‡å­—ï¼‰` | - |
| DB-E005 | DBä¿å­˜å¤±æ•—ï¼ˆnoteé–¢é€£ï¼‰ | `å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {reason}` | - |
| DB-E006 | ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•— | `ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: {reason}` | - |

### 6.2 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ–¹é‡

#### CLI-E010: ãƒ¡ãƒ¢é•·è¶…é

**ç™ºç”Ÿã‚¿ã‚¤ãƒŸãƒ³ã‚°**: `play_handler` å†…ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

**å‡¦ç†**:
1. `validate_note()` é–¢æ•°ã§ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
2. `play_handler` ãŒã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
4. æ¼”å¥ã¯å®Ÿè¡Œã•ã‚Œãªã„ï¼ˆå±¥æ­´ã‚‚ä¿å­˜ã•ã‚Œãªã„ï¼‰

**å®Ÿè£…ä¾‹**:
```rust
if let Some(ref note) = args.note {
    validate_note(note).context("[CLI-E010] ãƒ¡ãƒ¢ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ")?;
}
```

#### DB-E005: DBä¿å­˜å¤±æ•—

**ç™ºç”Ÿã‚¿ã‚¤ãƒŸãƒ³ã‚°**: `Database::save()` å†…ã®SQLå®Ÿè¡Œ

**å‡¦ç†**:
1. SQLã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
2. `DbError` ã«å¤‰æ›
3. `play_handler` ãŒè­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
4. æ¼”å¥ã¯ç¶™ç¶šï¼ˆå±¥æ­´ä¿å­˜å¤±æ•—ã¯è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼ã§ã¯ãªã„ï¼‰

**å®Ÿè£…ä¾‹**:
```rust
match db.save(&entry) {
    Ok(id) => Some(id),
    Err(e) => {
        eprintln!("Warning: å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}");
        None
    }
}
```

#### DB-E006: ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—

**ç™ºç”Ÿã‚¿ã‚¤ãƒŸãƒ³ã‚°**: `Database::init()` å†…ã® `migrate()` å‘¼ã³å‡ºã—

**å‡¦ç†**:
1. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
2. ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
3. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•ã‚’ä¸­æ–­

**å®Ÿè£…ä¾‹**:
```rust
pub fn migrate(conn: &Connection) -> Result<(), DbError> {
    conn.execute("BEGIN TRANSACTION", [])?;
    
    match try_migrate(conn) {
        Ok(_) => {
            conn.execute("COMMIT", [])?;
            Ok(())
        }
        Err(e) => {
            conn.execute("ROLLBACK", [])?;
            Err(e)
        }
    }
}
```

### 6.3 ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¾‹

```bash
# ãƒ¡ãƒ¢é•·è¶…é
$ sine-mml play "CDEFGAB" --note "$(python -c 'print("a"*501)')"
Error: [CLI-E010] ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: 501æ–‡å­—ï¼‰

# DBä¿å­˜å¤±æ•—ï¼ˆè­¦å‘Šã®ã¿ï¼‰
$ sine-mml play "CDEFGAB" --note "Test"
Warning: å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: database is locked
â™ª å†ç”Ÿä¸­...

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—ï¼ˆèµ·å‹•ä¸­æ–­ï¼‰
$ sine-mml play "CDEFGAB"
Error: [DB-E006] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: disk I/O error
```

---

## 7. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### 7.1 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

#### 7.1.1 `validate_note` é–¢æ•°ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/cli/handlers.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_note_valid() {
        // æ­£å¸¸ç³»: 500æ–‡å­—ä»¥å†…
        assert!(validate_note("My melody").is_ok());
        assert!(validate_note("").is_ok());
        assert!(validate_note(&"a".repeat(500)).is_ok());
    }

    #[test]
    fn test_validate_note_too_long() {
        // ç•°å¸¸ç³»: 501æ–‡å­—
        let result = validate_note(&"a".repeat(501));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("500æ–‡å­—ä»¥å†…"));
    }

    #[test]
    fn test_validate_note_utf8() {
        // UTF-8æ–‡å­—ï¼ˆçµµæ–‡å­—ï¼‰
        assert!(validate_note("ğŸµğŸ¶ğŸµ").is_ok());
        assert!(validate_note("ã‚ã„ã†ãˆãŠ").is_ok());
    }

    #[test]
    fn test_validate_note_char_count() {
        // æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ãƒˆï¼ˆãƒã‚¤ãƒˆæ•°ã§ã¯ãªã„ï¼‰
        let note = "ã‚".repeat(500);  // 1500ãƒã‚¤ãƒˆã ãŒ500æ–‡å­—
        assert!(validate_note(&note).is_ok());
        
        let note = "ã‚".repeat(501);  // 1503ãƒã‚¤ãƒˆã§501æ–‡å­—
        assert!(validate_note(&note).is_err());
    }
}
```

#### 7.1.2 `HistoryEntry::new` ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/db/history.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_history_entry_new_with_note() {
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            Some("My melody".to_string()),
        );
        
        assert_eq!(entry.mml, "CDEFGAB");
        assert_eq!(entry.note, Some("My melody".to_string()));
    }

    #[test]
    fn test_history_entry_new_without_note() {
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            None,
        );
        
        assert_eq!(entry.mml, "CDEFGAB");
        assert_eq!(entry.note, None);
    }
}
```

#### 7.1.3 DBãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/unit/db_migration_test.rs`

```rust
use rusqlite::Connection;
use sine_mml::db::schema::{initialize, migrate, CURRENT_VERSION};

#[test]
fn test_migrate_v1_to_v2() {
    let conn = Connection::open_in_memory().unwrap();
    
    // v1ã‚¹ã‚­ãƒ¼ãƒã‚’ä½œæˆ
    conn.execute(
        "CREATE TABLE history (
            id INTEGER PRIMARY KEY,
            mml TEXT NOT NULL,
            waveform TEXT NOT NULL,
            volume REAL NOT NULL,
            bpm INTEGER NOT NULL,
            created_at TEXT NOT NULL
        )",
        [],
    ).unwrap();
    
    conn.execute(
        "CREATE TABLE schema_version (version INTEGER PRIMARY KEY)",
        [],
    ).unwrap();
    
    conn.execute("INSERT INTO schema_version (version) VALUES (1)", []).unwrap();
    
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æŒ¿å…¥
    conn.execute(
        "INSERT INTO history (mml, waveform, volume, bpm, created_at)
         VALUES ('CDEFGAB', 'sine', 0.5, 120, '2026-01-11T10:00:00Z')",
        [],
    ).unwrap();
    
    // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    migrate(&conn).unwrap();
    
    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª
    let version: i64 = conn.query_row(
        "SELECT version FROM schema_version",
        [],
        |row| row.get(0),
    ).unwrap();
    assert_eq!(version, 2);
    
    // noteã‚«ãƒ©ãƒ ã®å­˜åœ¨ç¢ºèª
    let result: Result<Option<String>, _> = conn.query_row(
        "SELECT note FROM history WHERE id = 1",
        [],
        |row| row.get(0),
    );
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), None);  // æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯NULL
}

#[test]
fn test_migrate_idempotent() {
    let conn = Connection::open_in_memory().unwrap();
    initialize(&conn).unwrap();
    
    // 1å›ç›®ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    migrate(&conn).unwrap();
    let version1: i64 = conn.query_row(
        "SELECT version FROM schema_version",
        [],
        |row| row.get(0),
    ).unwrap();
    
    // 2å›ç›®ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå†ªç­‰æ€§ç¢ºèªï¼‰
    migrate(&conn).unwrap();
    let version2: i64 = conn.query_row(
        "SELECT version FROM schema_version",
        [],
        |row| row.get(0),
    ).unwrap();
    
    assert_eq!(version1, version2);
}
```

### 7.2 çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆE2Eï¼‰

#### 7.2.1 ãƒ¡ãƒ¢ä»˜ãæ¼”å¥ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cli_integration.rs`

```rust
use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::TempDir;

#[test]
fn test_play_with_note() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    // ãƒ¡ãƒ¢ä»˜ãæ¼”å¥
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", "My melody"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèª
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("My melody"));
}

#[test]
fn test_play_without_note() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    // ãƒ¡ãƒ¢ãªã—æ¼”å¥
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèªï¼ˆ"-" ãŒè¡¨ç¤ºã•ã‚Œã‚‹ï¼‰
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("-"));
}

#[test]
fn test_play_with_note_too_long() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    let long_note = "a".repeat(501);
    
    // 501æ–‡å­—ã®ãƒ¡ãƒ¢ï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", &long_note])
        .assert()
        .failure()
        .stderr(predicate::str::contains("500æ–‡å­—ä»¥å†…"));
}

#[test]
fn test_play_with_note_utf8() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    // UTF-8æ–‡å­—ï¼ˆçµµæ–‡å­—ï¼‰
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", "ğŸµ My melody ğŸ¶"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèª
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("ğŸµ My melody ğŸ¶"));
}

#[test]
fn test_play_with_note_and_loop() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã¨ãƒ¡ãƒ¢ã®ä½µç”¨
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--loop-play", "--note", "Loop test"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèª
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("Loop test"));
}
```

### 7.3 ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä¸€è¦§

| ãƒ†ã‚¹ãƒˆID | ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ | æœŸå¾…çµæœ | ãƒ†ã‚¹ãƒˆãƒ¬ãƒ™ãƒ« |
|---------|-------------|---------|-------------|
| TC-025-001 | `--note "My melody"` | ãƒ¡ãƒ¢ãŒä¿å­˜ã•ã‚Œã‚‹ | E2E |
| TC-025-002 | ãƒ¡ãƒ¢ãªã— | ãƒ¡ãƒ¢ã¯ NULLã€å±¥æ­´è¡¨ç¤ºã§ "-" | E2E |
| TC-025-003 | `--note "ã‚ã„ã†ãˆãŠğŸµ"` | UTF-8æ–‡å­—åˆ—ãŒä¿å­˜ã•ã‚Œã‚‹ | E2E |
| TC-025-004 | `--note "500æ–‡å­—ä»¥ä¸Š"` | ã‚¨ãƒ©ãƒ¼ï¼ˆé•·ã•åˆ¶é™ï¼‰ | E2E |
| TC-025-005 | `--note ""` | ç©ºæ–‡å­—åˆ—ãŒä¿å­˜ã•ã‚Œã‚‹ | E2E |
| TC-025-006 | `--loop-play --note "Loop test"` | ãƒ«ãƒ¼ãƒ—å†ç”Ÿã§ã‚‚ãƒ¡ãƒ¢ãŒä¿å­˜ã•ã‚Œã‚‹ | E2E |
| TC-025-007 | `validate_note("My melody")` | `Ok(())` | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-008 | `validate_note("a".repeat(501))` | `Err(...)` | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-009 | `HistoryEntry::new(..., Some("note"))` | `note` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¨­å®šã•ã‚Œã‚‹ | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-010 | `HistoryEntry::new(..., None)` | `note` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ `None` | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-011 | v1 DB â†’ v2 ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | `note` ã‚«ãƒ©ãƒ ãŒè¿½åŠ ã•ã‚Œã‚‹ | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-012 | æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã®ä¿æŒ | æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯ `note=NULL` ã§ä¿æŒ | ãƒ¦ãƒ‹ãƒƒãƒˆ |
| TC-025-013 | v2 DB â†’ v2ï¼ˆå†å®Ÿè¡Œï¼‰ | å¤‰æ›´ãªã—ï¼ˆå†ªç­‰æ€§ï¼‰ | ãƒ¦ãƒ‹ãƒƒãƒˆ |

---

## 8. å®Ÿè£…ã‚¿ã‚¹ã‚¯åˆ†å‰²ï¼ˆ200è¡Œä»¥ä¸‹ï¼‰

### 8.1 ã‚¿ã‚¹ã‚¯ä¸€è¦§

| ã‚¿ã‚¹ã‚¯ID | ã‚¿ã‚¹ã‚¯å | å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ« | æ¨å®šè¡Œæ•° | å„ªå…ˆåº¦ | ä¾å­˜é–¢ä¿‚ |
|---------|---------|-------------|---------|--------|---------|
| TASK-025-001 | DBã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã¨ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | `src/db/schema.rs` | 80è¡Œ | æœ€é«˜ | ãªã— |
| TASK-025-002 | `HistoryEntry` æ§‹é€ ä½“ã®å¤‰æ›´ | `src/db/history.rs` | 40è¡Œ | é«˜ | TASK-025-001 |
| TASK-025-003 | CLIã‚ªãƒ—ã‚·ãƒ§ãƒ³è¿½åŠ  | `src/cli/args.rs` | 20è¡Œ | é«˜ | ãªã— |
| TASK-025-004 | ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°å®Ÿè£… | `src/cli/handlers.rs` | 30è¡Œ | é«˜ | TASK-025-003 |
| TASK-025-005 | `play_handler` ã®å¤‰æ›´ | `src/cli/handlers.rs` | 50è¡Œ | é«˜ | TASK-025-002, TASK-025-004 |
| TASK-025-006 | `history_handler` ã®å¤‰æ›´ | `src/cli/handlers.rs` | 40è¡Œ | ä¸­ | TASK-025-002 |
| TASK-025-007 | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè£… | `src/db/history.rs`, `src/cli/handlers.rs` | 100è¡Œ | ä¸­ | TASK-025-001ã€œ006 |
| TASK-025-008 | E2Eãƒ†ã‚¹ãƒˆå®Ÿè£… | `tests/cli_integration.rs` | 150è¡Œ | ä¸­ | TASK-025-001ã€œ006 |

**åˆè¨ˆæ¨å®šè¡Œæ•°**: 510è¡Œï¼ˆå„ã‚¿ã‚¹ã‚¯ã¯200è¡Œä»¥ä¸‹ï¼‰

### 8.2 å®Ÿè£…é †åº

```mermaid
graph TD
    A[TASK-025-001<br>DBã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´] --> B[TASK-025-002<br>HistoryEntryå¤‰æ›´]
    C[TASK-025-003<br>CLIã‚ªãƒ—ã‚·ãƒ§ãƒ³è¿½åŠ ] --> D[TASK-025-004<br>ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…]
    B --> E[TASK-025-005<br>play_handlerå¤‰æ›´]
    D --> E
    B --> F[TASK-025-006<br>history_handlerå¤‰æ›´]
    E --> G[TASK-025-007<br>ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ]
    F --> G
    G --> H[TASK-025-008<br>E2Eãƒ†ã‚¹ãƒˆ]
    
    style A fill:#ffcccb
    style B fill:#ffcccb
    style C fill:#add8e6
    style D fill:#add8e6
    style E fill:#90ee90
    style F fill:#90ee90
    style G fill:#ffffe0
    style H fill:#ffffe0
```

**æ¨å¥¨å®Ÿè£…é †åº**:
1. **TASK-025-001** (DBã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´) - æœ€å„ªå…ˆã€ä»–ã®ã‚¿ã‚¹ã‚¯ã®åŸºç›¤
2. **TASK-025-003** (CLIã‚ªãƒ—ã‚·ãƒ§ãƒ³è¿½åŠ ) - ä¸¦è¡Œå®Ÿè£…å¯èƒ½
3. **TASK-025-002** (HistoryEntryå¤‰æ›´) - TASK-025-001å®Œäº†å¾Œ
4. **TASK-025-004** (ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…) - TASK-025-003å®Œäº†å¾Œ
5. **TASK-025-005** (play_handlerå¤‰æ›´) - TASK-025-002, 004å®Œäº†å¾Œ
6. **TASK-025-006** (history_handlerå¤‰æ›´) - TASK-025-002å®Œäº†å¾Œ
7. **TASK-025-007** (ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ) - TASK-025-001ã€œ006å®Œäº†å¾Œ
8. **TASK-025-008** (E2Eãƒ†ã‚¹ãƒˆ) - TASK-025-007å®Œäº†å¾Œ

**æ‰€è¦æ™‚é–“è¦‹ç©ã‚‚ã‚Š**: 2-3æ—¥

---

## 9. é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

| ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ | ãƒ‘ã‚¹ | é–¢é€£æ€§ |
|-------------|------|--------|
| è¦ä»¶å®šç¾©æ›¸ | `docs/requirements/REQ-CLI-003_MML-Syntax-Extension.md` | æ©Ÿèƒ½è¦ä»¶ã®å…ƒ |
| åŸºæœ¬è¨­è¨ˆæ›¸ | `docs/designs/basic/BASIC-CLI-003_MML-Syntax-Extension.md` | æœ¬è¨­è¨ˆæ›¸ã®è¦ª |
| DBãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆæ›¸ | `docs/designs/detailed/db-migration-v2/è©³ç´°è¨­è¨ˆæ›¸.md` | DBã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã®è©³ç´° |
| å±¥æ­´å‰Šé™¤æ©Ÿèƒ½è¨­è¨ˆæ›¸ | `docs/designs/detailed/history-management/å±¥æ­´å‰Šé™¤æ©Ÿèƒ½.md` | åŒã˜å±¥æ­´ç®¡ç†æ©Ÿèƒ½ |

---

## 10. å¤‰æ›´å±¥æ­´

| æ—¥ä»˜ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | å¤‰æ›´å†…å®¹ | æ‹…å½“è€… |
|:---|:---|:---|:---|
| 2026-01-11 | 1.0.0 | åˆç‰ˆä½œæˆ | detailed-design-writer |
