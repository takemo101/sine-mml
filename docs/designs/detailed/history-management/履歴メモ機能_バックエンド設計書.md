# å±¥æ­´ãƒ¡ãƒ¢æ©Ÿèƒ½ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰è¨­è¨ˆæ›¸

## 0. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±

| é …ç›® | å†…å®¹ |
|------|------|
| ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆID | DET-NOTE-001-BE |
| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | 1.0.0 |
| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾…ã¡ |
| ä½œæˆæ—¥ | 2026-01-11 |
| æœ€çµ‚æ›´æ–°æ—¥ | 2026-01-11 |
| è¦ªæ©Ÿèƒ½ | å±¥æ­´ç®¡ç†æ©Ÿèƒ½æ‹¡å¼µ |
| å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ID | F-025 |
| é–¢é€£åŸºæœ¬è¨­è¨ˆæ›¸ | BASIC-CLI-003_MML-Syntax-Extension.md |
| é–¢é€£è¦ä»¶å®šç¾©æ›¸ | REQ-CLI-003_MML-Syntax-Extension.md |

---

## 1. å¤‰æ›´æ¦‚è¦

### 1.1 ç›®çš„

sine-mml v2.0ã«ãŠã„ã¦ã€æ¼”å¥å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ã§ãã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹ã€‚`--note`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ä»»æ„ã®ãƒ¡ãƒ¢ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰ã‚’æŒ‡å®šã—ã€å¾Œã§å±¥æ­´ã‚’è¦‹è¿”ã—ãŸã¨ãã«ä½•ã®æ›²ã‹è­˜åˆ¥ã—ã‚„ã™ãã™ã‚‹ã€‚

### 1.2 å¤‰æ›´å¯¾è±¡ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ | å¤‰æ›´ç¨®åˆ¥ | å¤‰æ›´å†…å®¹ |
|---------------|-------------|---------|---------|
| CLIå¼•æ•°å®šç¾© | `src/cli/args.rs` | æ‹¡å¼µ | `PlayArgs`ã«`note`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ  |
| ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ« | `src/db/history.rs` | æ‹¡å¼µ | `HistoryEntry`ã«`note`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ  |
| DBæ“ä½œ | `src/db/mod.rs` | ä¿®æ­£ | `save()`ã€`list()`ã€`get_by_id()`ã«noteå¯¾å¿œ |
| ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ | `src/cli/handlers.rs` | ä¿®æ­£ | `play_handler()`ã§noteä¿å­˜ã€`history_handler()`ã§è¡¨ç¤º |
| DBã‚¹ã‚­ãƒ¼ãƒ | `src/db/schema.rs` | ä¿®æ­£ | `note`ã‚«ãƒ©ãƒ è¿½åŠ ï¼ˆãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ |

### 1.3 å¤‰æ›´å½±éŸ¿ç¯„å›²

```mermaid
graph LR
    subgraph "CLI Layer"
        A[PlayArgs<br/>--noteè¿½åŠ ]
    end
    
    subgraph "Handler Layer"
        B[play_handler<br/>noteä¿å­˜å‡¦ç†]
        C[history_handler<br/>noteè¡¨ç¤ºå‡¦ç†]
    end
    
    subgraph "Data Layer"
        D[HistoryEntry<br/>noteãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰]
        E[Database::save<br/>INSERT with note]
        F[Database::list<br/>SELECT with note]
    end
    
    subgraph "Schema Layer"
        G[schema.rs<br/>note ã‚«ãƒ©ãƒ è¿½åŠ ]
    end
    
    A --> B
    B --> D
    D --> E
    E --> G
    C --> F
    F --> G
    
    style A fill:#ffcccb
    style B fill:#ffffcc
    style C fill:#ffffcc
    style D fill:#ccffcc
    style E fill:#ccffcc
    style F fill:#ccffcc
    style G fill:#add8e6
```

---

## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ

### 2.1 ä¾å­˜é–¢ä¿‚

```mermaid
graph TD
    subgraph "src/cli/"
        Args[args.rs<br/>PlayArgs::note]
        Handlers[handlers.rs<br/>play_handler]
    end
    
    subgraph "src/db/"
        History[history.rs<br/>HistoryEntry]
        Mod[mod.rs<br/>Database]
        Schema[schema.rs<br/>migration]
    end
    
    Args --> Handlers
    Handlers --> Mod
    Mod --> History
    Mod --> Schema
    
    style Args fill:#ffcccb
    style Handlers fill:#ffffcc
    style History fill:#ccffcc
    style Mod fill:#ccffcc
    style Schema fill:#add8e6
```

### 2.2 ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©

#### 2.2.1 CLIå¼•æ•°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```rust
// src/cli/args.rs

pub struct PlayArgs {
    // ... æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ...
    pub mml: Option<String>,
    pub history_id: Option<i64>,
    pub waveform: Waveform,
    pub volume: f32,
    pub loop_play: bool,
    pub metronome: bool,
    pub metronome_beat: u8,
    pub metronome_volume: f32,
    
    /// å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰
    pub note: Option<String>,
}
```

#### 2.2.2 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```rust
// src/db/history.rs

pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub note: Option<String>,  // æ–°è¦è¿½åŠ 
    pub created_at: DateTime<Utc>,
}

impl HistoryEntry {
    /// æ–°è¦ã‚¨ãƒ³ãƒˆãƒªã‚’ä½œæˆ
    pub fn new(
        mml: String,
        waveform: Waveform,
        volume: f32,
        bpm: u16,
        note: Option<String>,  // æ–°è¦è¿½åŠ 
    ) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            note,
            created_at: Utc::now(),
        }
    }
}
```

#### 2.2.3 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```rust
// src/db/mod.rs

impl Database {
    /// å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªã‚’ä¿å­˜
    ///
    /// # Arguments
    /// * `entry` - ä¿å­˜ã™ã‚‹å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªï¼ˆnoteã‚’å«ã‚€ï¼‰
    ///
    /// # Returns
    /// * `Ok(i64)` - æŒ¿å…¥ã•ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰ã®ID
    /// * `Err(DbError)` - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯DBæ“ä½œã‚¨ãƒ©ãƒ¼
    pub fn save(&self, entry: &HistoryEntry) -> Result<i64, DbError>;
    
    /// å±¥æ­´ä¸€è¦§ã‚’å–å¾—
    ///
    /// # Arguments
    /// * `limit` - å–å¾—ä»¶æ•°ã®ä¸Šé™ï¼ˆNoneã®å ´åˆã¯å…¨ä»¶ï¼‰
    ///
    /// # Returns
    /// * `Ok(Vec<HistoryEntry>)` - å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªã®ãƒªã‚¹ãƒˆï¼ˆnoteã‚’å«ã‚€ï¼‰
    /// * `Err(DbError)` - DBæ“ä½œã‚¨ãƒ©ãƒ¼
    pub fn list(&self, limit: Option<usize>) -> Result<Vec<HistoryEntry>, DbError>;
    
    /// IDã§å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªã‚’å–å¾—
    ///
    /// # Arguments
    /// * `id` - å±¥æ­´ID
    ///
    /// # Returns
    /// * `Ok(HistoryEntry)` - å±¥æ­´ã‚¨ãƒ³ãƒˆãƒªï¼ˆnoteã‚’å«ã‚€ï¼‰
    /// * `Err(DbError::NotFound)` - æŒ‡å®šIDãŒå­˜åœ¨ã—ãªã„
    /// * `Err(DbError)` - DBæ“ä½œã‚¨ãƒ©ãƒ¼
    pub fn get_by_id(&self, id: i64) -> Result<HistoryEntry, DbError>;
}
```

---

## 3. å®Ÿè£…è©³ç´°

### 3.1 CLIå¼•æ•°æ‹¡å¼µ

#### 3.1.1 å¤‰æ›´å†…å®¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/cli/args.rs`

**å¤‰æ›´å‰**:
```rust
pub struct PlayArgs {
    pub mml: Option<String>,
    pub history_id: Option<i64>,
    pub waveform: Waveform,
    pub volume: f32,
    pub loop_play: bool,
    pub metronome: bool,
    pub metronome_beat: u8,
    pub metronome_volume: f32,
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub struct PlayArgs {
    pub mml: Option<String>,
    pub history_id: Option<i64>,
    pub waveform: Waveform,
    pub volume: f32,
    pub loop_play: bool,
    pub metronome: bool,
    pub metronome_beat: u8,
    pub metronome_volume: f32,
    
    /// å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰
    #[arg(long, help = "å±¥æ­´ã«ãƒ¡ãƒ¢ã‚’ä»˜ä¸ï¼ˆæœ€å¤§500æ–‡å­—ï¼‰")]
    pub note: Option<String>,
}
```

#### 3.1.2 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

ãƒ¡ãƒ¢ã®é•·ã•åˆ¶é™ï¼ˆ500æ–‡å­—ï¼‰ã¯**ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤**ã§å®Ÿæ–½ã™ã‚‹ï¼ˆCLIå¼•æ•°ãƒ‘ãƒ¼ã‚¹æ™‚ã§ã¯ãªã„ï¼‰ã€‚

**ç†ç”±**:
- clapã®ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã¯æ–‡å­—åˆ—é•·ã§ã¯ãªããƒã‚¤ãƒˆé•·ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã€ãƒãƒ«ãƒãƒã‚¤ãƒˆæ–‡å­—ï¼ˆæ—¥æœ¬èªã€çµµæ–‡å­—ï¼‰ã§èª¤åˆ¤å®šãŒç™ºç”Ÿã™ã‚‹
- ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ã§`chars().count()`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§æ­£ç¢ºãªæ–‡å­—æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆå¯èƒ½

---

### 3.2 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«æ‹¡å¼µ

#### 3.2.1 å¤‰æ›´å†…å®¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/db/history.rs`

**å¤‰æ›´å‰**:
```rust
pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub created_at: DateTime<Utc>,
}

impl HistoryEntry {
    pub fn new(mml: String, waveform: Waveform, volume: f32, bpm: u16) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            created_at: Utc::now(),
        }
    }
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub note: Option<String>,  // æ–°è¦è¿½åŠ 
    pub created_at: DateTime<Utc>,
}

impl HistoryEntry {
    pub fn new(
        mml: String,
        waveform: Waveform,
        volume: f32,
        bpm: u16,
        note: Option<String>,  // æ–°è¦è¿½åŠ 
    ) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            note,
            created_at: Utc::now(),
        }
    }
}
```

#### 3.2.2 ãƒ‡ãƒ¼ã‚¿å‹ã®é¸æŠç†ç”±

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ | å‹ | ç†ç”± |
|-----------|-----|------|
| `note` | `Option<String>` | ãƒ¡ãƒ¢ã¯ä»»æ„é …ç›®ï¼ˆæŒ‡å®šã—ãªãã¦ã‚‚å‹•ä½œã™ã‚‹ï¼‰ |
| `String` | UTF-8æ–‡å­—åˆ— | æ—¥æœ¬èªã€çµµæ–‡å­—ã‚’å«ã‚€ä»»æ„ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ |

---

### 3.3 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œæ‹¡å¼µ

#### 3.3.1 `save()`ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤‰æ›´

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/db/mod.rs`

**å¤‰æ›´å‰**:
```rust
pub fn save(&self, entry: &HistoryEntry) -> Result<i64, DbError> {
    // ... ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç† ...
    
    self.conn.execute(
        "INSERT INTO history (mml, waveform, volume, bpm, created_at) VALUES (?, ?, ?, ?, ?)",
        params![
            entry.mml,
            entry.waveform.as_str(),
            entry.volume,
            entry.bpm,
            entry.created_at.to_rfc3339()
        ],
    )?;
    
    Ok(self.conn.last_insert_rowid())
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn save(&self, entry: &HistoryEntry) -> Result<i64, DbError> {
    // æ—¢å­˜ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if entry.mml.is_empty() {
        return Err(DbError::SaveFailed("MML cannot be empty".to_string()));
    }
    if entry.mml.len() > 10000 {
        return Err(DbError::SaveFailed("MML too long (max 10000 chars)".to_string()));
    }
    if entry.volume < 0.0 || entry.volume > 1.0 {
        return Err(DbError::SaveFailed("Volume must be between 0.0 and 1.0".to_string()));
    }
    if entry.bpm < 30 || entry.bpm > 300 {
        return Err(DbError::SaveFailed("BPM must be between 30 and 300".to_string()));
    }
    
    // æ–°è¦ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: noteã®é•·ã•ãƒã‚§ãƒƒã‚¯
    if let Some(ref note) = entry.note {
        if note.chars().count() > 500 {
            return Err(DbError::SaveFailed(
                "Note must be 500 characters or less".to_string()
            ));
        }
    }
    
    self.conn.execute(
        "INSERT INTO history (mml, waveform, volume, bpm, note, created_at) VALUES (?, ?, ?, ?, ?, ?)",
        params![
            entry.mml,
            entry.waveform.as_str(),
            entry.volume,
            entry.bpm,
            entry.note,  // æ–°è¦è¿½åŠ 
            entry.created_at.to_rfc3339()
        ],
    )?;
    
    Ok(self.conn.last_insert_rowid())
}
```

#### 3.3.2 `list()`ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
pub fn list(&self, limit: Option<usize>) -> Result<Vec<HistoryEntry>, DbError> {
    let sql = if let Some(l) = limit {
        format!("SELECT id, mml, waveform, volume, bpm, created_at FROM history ORDER BY created_at DESC LIMIT {l}")
    } else {
        "SELECT id, mml, waveform, volume, bpm, created_at FROM history ORDER BY created_at DESC".to_string()
    };
    
    let mut stmt = self.conn.prepare(&sql)?;
    let rows = stmt.query_map([], |row| {
        // ... æ—¢å­˜ã®ãƒãƒƒãƒ”ãƒ³ã‚°å‡¦ç† ...
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform,
            volume: row.get(3)?,
            bpm: row.get(4)?,
            created_at,
        })
    })?;
    
    // ... çµæœã®åé›† ...
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn list(&self, limit: Option<usize>) -> Result<Vec<HistoryEntry>, DbError> {
    let sql = if let Some(l) = limit {
        format!("SELECT id, mml, waveform, volume, bpm, note, created_at FROM history ORDER BY created_at DESC LIMIT {l}")
    } else {
        "SELECT id, mml, waveform, volume, bpm, note, created_at FROM history ORDER BY created_at DESC".to_string()
    };
    
    let mut stmt = self.conn.prepare(&sql)?;
    let rows = stmt.query_map([], |row| {
        let waveform_str: String = row.get(2)?;
        let waveform = waveform_str.parse::<Waveform>().map_err(|e| {
            rusqlite::Error::FromSqlConversionFailure(
                2,
                rusqlite::types::Type::Text,
                Box::new(e),
            )
        })?;
        
        let created_at_str: String = row.get(6)?;  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¤‰æ›´: 5 â†’ 6
        let created_at = DateTime::parse_from_rfc3339(&created_at_str)
            .map_err(|e| {
                rusqlite::Error::FromSqlConversionFailure(
                    6,
                    rusqlite::types::Type::Text,
                    Box::new(e),
                )
            })?
            .with_timezone(&Utc);
        
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform,
            volume: row.get(3)?,
            bpm: row.get(4)?,
            note: row.get(5)?,  // æ–°è¦è¿½åŠ 
            created_at,
        })
    })?;
    
    let mut entries = Vec::new();
    for row in rows {
        entries.push(row?);
    }
    
    Ok(entries)
}
```

#### 3.3.3 `get_by_id()`ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
pub fn get_by_id(&self, id: i64) -> Result<HistoryEntry, DbError> {
    let mut stmt = self.conn.prepare(
        "SELECT id, mml, waveform, volume, bpm, created_at FROM history WHERE id = ?",
    )?;
    
    let result = stmt.query_row(params![id], |row| {
        // ... æ—¢å­˜ã®ãƒãƒƒãƒ”ãƒ³ã‚°å‡¦ç† ...
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform,
            volume: row.get(3)?,
            bpm: row.get(4)?,
            created_at,
        })
    });
    
    // ... ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ...
}
```

**å¤‰æ›´å¾Œ**:
```rust
pub fn get_by_id(&self, id: i64) -> Result<HistoryEntry, DbError> {
    let mut stmt = self.conn.prepare(
        "SELECT id, mml, waveform, volume, bpm, note, created_at FROM history WHERE id = ?",
    )?;
    
    let result = stmt.query_row(params![id], |row| {
        let waveform_str: String = row.get(2)?;
        let waveform = waveform_str.parse::<Waveform>().map_err(|e| {
            rusqlite::Error::FromSqlConversionFailure(
                2,
                rusqlite::types::Type::Text,
                Box::new(e),
            )
        })?;
        
        let created_at_str: String = row.get(6)?;  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¤‰æ›´: 5 â†’ 6
        let created_at = DateTime::parse_from_rfc3339(&created_at_str)
            .map_err(|e| {
                rusqlite::Error::FromSqlConversionFailure(
                    6,
                    rusqlite::types::Type::Text,
                    Box::new(e),
                )
            })?
            .with_timezone(&Utc);
        
        Ok(HistoryEntry {
            id: Some(row.get(0)?),
            mml: row.get(1)?,
            waveform,
            volume: row.get(3)?,
            bpm: row.get(4)?,
            note: row.get(5)?,  // æ–°è¦è¿½åŠ 
            created_at,
        })
    });
    
    match result {
        Ok(entry) => Ok(entry),
        Err(rusqlite::Error::QueryReturnedNoRows) => Err(DbError::NotFound(id)),
        Err(e) => Err(DbError::Rusqlite(e)),
    }
}
```

---

### 3.4 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…

#### 3.4.1 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/cli/handlers.rs`

```rust
/// ãƒ¡ãƒ¢ã®é•·ã•ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
///
/// # Arguments
/// * `note` - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾è±¡ã®ãƒ¡ãƒ¢
///
/// # Returns
/// * `Ok(())` - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ
/// * `Err(anyhow::Error)` - 500æ–‡å­—è¶…é
fn validate_note(note: &Option<String>) -> Result<()> {
    if let Some(n) = note {
        if n.chars().count() > 500 {
            bail!("[CLI-E010] ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: {}æ–‡å­—ï¼‰", n.chars().count());
        }
    }
    Ok(())
}
```

#### 3.4.2 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«

| ãƒ«ãƒ¼ãƒ«ID | æ¤œè¨¼é …ç›® | æ¡ä»¶ | ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ |
|---------|---------|------|------------|
| VAL-NOTE-001 | ãƒ¡ãƒ¢ã®é•·ã• | 500æ–‡å­—ä»¥å†… | CLI-E010 |
| VAL-NOTE-002 | ãƒ¡ãƒ¢ã®æ–‡å­—ç¨® | UTF-8æ–‡å­—åˆ—ï¼ˆåˆ¶é™ãªã—ï¼‰ | - |
| VAL-NOTE-003 | ãƒ¡ãƒ¢ã®å¿…é ˆæ€§ | ä»»æ„ï¼ˆNoneã‚‚è¨±å¯ï¼‰ | - |

#### 3.4.3 ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°

```mermaid
sequenceDiagram
    autonumber
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼
    participant Handler as play_handler
    participant Validator as validate_note
    participant DB as Database::save
    
    User->>Handler: play "CDEFGAB" --note "My melody"
    Handler->>Validator: validate_note(&note)
    
    alt ãƒ¡ãƒ¢ãŒ500æ–‡å­—ä»¥å†…
        Validator-->>Handler: Ok(())
        Handler->>DB: save(entry)
        DB-->>Handler: Ok(id)
        Handler-->>User: âœ“ å±¥æ­´ID: 42
    else ãƒ¡ãƒ¢ãŒ500æ–‡å­—è¶…é
        Validator-->>Handler: Err(CLI-E010)
        Handler-->>User: ã‚¨ãƒ©ãƒ¼: ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„
    end
```

---

### 3.5 ãƒãƒ³ãƒ‰ãƒ©ãƒ¼æ›´æ–°

#### 3.5.1 `play_handler()`ã®å¤‰æ›´

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/cli/handlers.rs`

**å¤‰æ›´ç®‡æ‰€**:

```rust
pub fn play_handler(args: PlayArgs) -> Result<()> {
    // 1. ãƒ¡ãƒ¢ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    validate_note(&args.note)?;
    
    // 2-4. æ—¢å­˜å‡¦ç†ï¼ˆMMLè§£æã€éŸ³å£°åˆæˆï¼‰
    // ... çœç•¥ ...
    
    // 5. å±¥æ­´ä¿å­˜ï¼ˆå¤‰æ›´ç®‡æ‰€ï¼‰
    let history_id_opt = if should_save {
        let db = db::Database::init()?;
        
        let db_waveform = match args.waveform {
            Waveform::Sine => db::history::Waveform::Sine,
            Waveform::Sawtooth => db::history::Waveform::Sawtooth,
            Waveform::Square => db::history::Waveform::Square,
        };
        
        let bpm_u16 = 120;
        
        // HistoryEntry::new()ã«noteã‚’æ¸¡ã™ï¼ˆå¤‰æ›´ç®‡æ‰€ï¼‰
        let entry = db::HistoryEntry::new(
            mml_string.clone(),
            db_waveform,
            args.volume,
            bpm_u16,
            args.note.clone(),  // æ–°è¦è¿½åŠ 
        );
        
        match db.save(&entry) {
            Ok(id) => Some(id),
            Err(e) => {
                eprintln!("Warning: å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}");
                None
            }
        }
    } else {
        None
    };
    
    // 6-7. æ—¢å­˜å‡¦ç†ï¼ˆå†ç”Ÿã€æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰
    // ... çœç•¥ ...
    
    Ok(())
}
```

#### 3.5.2 `history_handler()`ã®å¤‰æ›´

**å¤‰æ›´å‰**:
```rust
fn history_logic(db: &db::Database) -> Result<()> {
    let history = db.list(Some(20)).context("å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")?;
    
    if history.is_empty() {
        println!("å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“");
        return Ok(());
    }
    
    let mut table = Table::new();
    table
        .load_preset(comfy_table::presets::UTF8_FULL)
        .set_header(vec!["ID", "MML", "Waveform", "Volume", "BPM", "Created At"]);
    
    for entry in history {
        table.add_row(vec![
            entry.id.map_or(String::new(), |id| id.to_string()),
            truncate_mml(&entry.mml, 50),
            format!("{:?}", entry.waveform),
            format!("{:.1}", entry.volume),
            entry.bpm.to_string(),
            entry.created_at.format("%Y-%m-%d %H:%M:%S").to_string(),
        ]);
    }
    
    println!("{table}");
    Ok(())
}
```

**å¤‰æ›´å¾Œ**:
```rust
fn history_logic(db: &db::Database) -> Result<()> {
    let history = db.list(Some(20)).context("å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")?;
    
    if history.is_empty() {
        println!("å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“");
        return Ok(());
    }
    
    let mut table = Table::new();
    table
        .load_preset(comfy_table::presets::UTF8_FULL)
        .set_header(vec!["ID", "MML", "Waveform", "Volume", "BPM", "Created At", "Note"]);  // "Note"åˆ—è¿½åŠ 
    
    for entry in history {
        table.add_row(vec![
            entry.id.map_or(String::new(), |id| id.to_string()),
            truncate_mml(&entry.mml, 50),
            format!("{:?}", entry.waveform),
            format!("{:.1}", entry.volume),
            entry.bpm.to_string(),
            entry.created_at.format("%Y-%m-%d %H:%M:%S").to_string(),
            entry.note.unwrap_or_else(|| "-".to_string()),  // ãƒ¡ãƒ¢ãªã—ã¯ "-"
        ]);
    }
    
    println!("{table}");
    Ok(())
}
```

---

## 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…

### 4.1 ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰å®šç¾©

| ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ | èª¬æ˜ | ç™ºç”Ÿæ¡ä»¶ | å¯¾å‡¦æ–¹æ³• |
|------------|------|---------|---------|
| CLI-E010 | ãƒ¡ãƒ¢ã®é•·ã•è¶…é | ãƒ¡ãƒ¢ãŒ500æ–‡å­—ã‚’è¶…ãˆã‚‹ | ãƒ¡ãƒ¢ã‚’500æ–‡å­—ä»¥å†…ã«çŸ­ç¸® |
| DB-E004 | å±¥æ­´ä¿å­˜å¤±æ•—ï¼ˆnoteé–¢é€£ï¼‰ | DBã¸ã®INSERTå¤±æ•— | ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çŠ¶æ…‹ã‚’ç¢ºèª |

### 4.2 ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

#### CLI-E010: ãƒ¡ãƒ¢ã®é•·ã•è¶…é

```
ã‚¨ãƒ©ãƒ¼: [CLI-E010] ãƒ¡ãƒ¢ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨: 523æ–‡å­—ï¼‰
```

#### DB-E004: å±¥æ­´ä¿å­˜å¤±æ•—

```
ã‚¨ãƒ©ãƒ¼: [DB-E004] å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: Note must be 500 characters or less
```

### 4.3 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ•ãƒ­ãƒ¼

```mermaid
flowchart TD
    Start[play --note å…¥åŠ›] --> Validate{ãƒ¡ãƒ¢ã®é•·ã•<br/>â‰¤ 500æ–‡å­—?}
    
    Validate -->|Yes| Parse[MMLè§£æ]
    Validate -->|No| Error1[CLI-E010ã‚¨ãƒ©ãƒ¼]
    
    Parse --> Synth[éŸ³å£°åˆæˆ]
    Synth --> Save{å±¥æ­´ä¿å­˜}
    
    Save -->|æˆåŠŸ| Play[å†ç”Ÿ]
    Save -->|å¤±æ•—| Warn[è­¦å‘Šè¡¨ç¤º<br/>â€»å†ç”Ÿã¯ç¶™ç¶š]
    
    Play --> Success[âœ“ å†ç”Ÿå®Œäº†]
    Warn --> Play
    
    Error1 --> Exit1[çµ‚äº†ã‚³ãƒ¼ãƒ‰: 1]
    Success --> Exit0[çµ‚äº†ã‚³ãƒ¼ãƒ‰: 0]
    
    style Success fill:#ccffcc
    style Error1 fill:#ffcccc
    style Warn fill:#ffffcc
```

---

## 5. ãƒ†ã‚¹ãƒˆå®Ÿè£…

### 5.1 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

#### 5.1.1 `HistoryEntry::new()`ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/db/history.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_history_entry_new_with_note() {
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            Some("My melody".to_string()),
        );
        
        assert_eq!(entry.mml, "CDEFGAB");
        assert_eq!(entry.waveform, Waveform::Sine);
        assert_eq!(entry.volume, 0.5);
        assert_eq!(entry.bpm, 120);
        assert_eq!(entry.note, Some("My melody".to_string()));
        assert!(entry.id.is_none());
    }
    
    #[test]
    fn test_history_entry_new_without_note() {
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            None,
        );
        
        assert_eq!(entry.note, None);
    }
}
```

#### 5.1.2 `validate_note()`ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/cli/handlers.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_validate_note_valid() {
        let note = Some("My melody".to_string());
        assert!(validate_note(&note).is_ok());
    }
    
    #[test]
    fn test_validate_note_none() {
        let note = None;
        assert!(validate_note(&note).is_ok());
    }
    
    #[test]
    fn test_validate_note_empty() {
        let note = Some("".to_string());
        assert!(validate_note(&note).is_ok());
    }
    
    #[test]
    fn test_validate_note_exactly_500_chars() {
        let note = Some("a".repeat(500));
        assert!(validate_note(&note).is_ok());
    }
    
    #[test]
    fn test_validate_note_over_500_chars() {
        let note = Some("a".repeat(501));
        let result = validate_note(&note);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("CLI-E010"));
    }
    
    #[test]
    fn test_validate_note_multibyte_chars() {
        // æ—¥æœ¬èª250æ–‡å­—ï¼ˆ500ãƒã‚¤ãƒˆè¶…éã ãŒæ–‡å­—æ•°ã¯500ä»¥å†…ï¼‰
        let note = Some("ã‚".repeat(250));
        assert!(validate_note(&note).is_ok());
    }
    
    #[test]
    fn test_validate_note_emoji() {
        // çµµæ–‡å­—ã‚’å«ã‚€ãƒ¡ãƒ¢
        let note = Some("My melody ğŸµğŸ¶".to_string());
        assert!(validate_note(&note).is_ok());
    }
}
```

#### 5.1.3 `Database::save()`ã®ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/db/mod.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_save_with_note() {
        let db = Database::open_in_memory().unwrap();
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            Some("My melody".to_string()),
        );
        
        let id = db.save(&entry).unwrap();
        let fetched = db.get_by_id(id).unwrap();
        
        assert_eq!(fetched.note, Some("My melody".to_string()));
    }
    
    #[test]
    fn test_save_without_note() {
        let db = Database::open_in_memory().unwrap();
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            None,
        );
        
        let id = db.save(&entry).unwrap();
        let fetched = db.get_by_id(id).unwrap();
        
        assert_eq!(fetched.note, None);
    }
    
    #[test]
    fn test_save_note_over_500_chars() {
        let db = Database::open_in_memory().unwrap();
        let entry = HistoryEntry::new(
            "CDEFGAB".to_string(),
            Waveform::Sine,
            0.5,
            120,
            Some("a".repeat(501)),
        );
        
        let result = db.save(&entry);
        assert!(result.is_err());
        match result {
            Err(DbError::SaveFailed(msg)) => {
                assert!(msg.contains("Note must be 500 characters or less"));
            }
            _ => panic!("Expected SaveFailed error"),
        }
    }
}
```

#### 5.1.4 `Database::list()`ã®ãƒ†ã‚¹ãƒˆ

```rust
#[test]
fn test_list_with_note() {
    let db = Database::open_in_memory().unwrap();
    
    let entry1 = HistoryEntry::new(
        "CDEFGAB".to_string(),
        Waveform::Sine,
        0.5,
        120,
        Some("First melody".to_string()),
    );
    let entry2 = HistoryEntry::new(
        "GABCDEF".to_string(),
        Waveform::Square,
        0.7,
        140,
        None,
    );
    
    db.save(&entry1).unwrap();
    db.save(&entry2).unwrap();
    
    let list = db.list(None).unwrap();
    assert_eq!(list.len(), 2);
    assert_eq!(list[0].note, None);  // æ–°ã—ã„é †ï¼ˆentry2ï¼‰
    assert_eq!(list[1].note, Some("First melody".to_string()));  // entry1
}
```

### 5.2 çµ±åˆãƒ†ã‚¹ãƒˆ

#### 5.2.1 E2Eãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/cli_integration.rs`

```rust
#[test]
fn test_play_with_note_option() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", "My first melody"])
        .assert()
        .success()
        .stdout(predicate::str::contains("âœ“ å†ç”Ÿå®Œäº†"));
    
    // å±¥æ­´ç¢ºèª
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("My first melody"));
}

#[test]
fn test_play_without_note_option() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèªï¼ˆãƒ¡ãƒ¢ãªã—ã¯ "-" ã¨è¡¨ç¤ºï¼‰
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("-"));
}

#[test]
fn test_play_with_note_over_500_chars() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    let long_note = "a".repeat(501);
    
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", &long_note])
        .assert()
        .failure()
        .stderr(predicate::str::contains("CLI-E010"));
}

#[test]
fn test_play_with_multibyte_note() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path().join("test.db");
    
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["play", "CDEFGAB", "--note", "æ—¥æœ¬èªã®ãƒ¡ãƒ¢ğŸµ"])
        .assert()
        .success();
    
    // å±¥æ­´ç¢ºèª
    Command::cargo_bin("sine-mml")
        .unwrap()
        .env("SINE_MML_DB_PATH", db_path.to_str().unwrap())
        .args(&["history"])
        .assert()
        .success()
        .stdout(predicate::str::contains("æ—¥æœ¬èªã®ãƒ¡ãƒ¢ğŸµ"));
}
```

### 5.3 ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

| ãƒ†ã‚¹ãƒˆãƒ¬ãƒ™ãƒ« | å¯¾è±¡ | ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™ |
|-------------|------|---------------|
| ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ | `validate_note()` | 100% |
| ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ | `HistoryEntry::new()` | 100% |
| ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ | `Database::save()` | 100% |
| ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ | `Database::list()` | 100% |
| çµ±åˆãƒ†ã‚¹ãƒˆ | `play_handler()` | 100% |
| E2Eãƒ†ã‚¹ãƒˆ | ä¸»è¦ã‚·ãƒŠãƒªã‚ª | 100% |

---

## 6. é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

| ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ | ãƒ‘ã‚¹ | èª¬æ˜ |
|------------|------|------|
| åŸºæœ¬è¨­è¨ˆæ›¸ | [BASIC-CLI-003](../../basic/BASIC-CLI-003_MML-Syntax-Extension.md) | MMLæ§‹æ–‡æ‹¡å¼µã®åŸºæœ¬è¨­è¨ˆ |
| è¦ä»¶å®šç¾©æ›¸ | [REQ-CLI-003](../../../requirements/REQ-CLI-003_MML-Syntax-Extension.md) | è¦ä»¶å®šç¾© |
| å±¥æ­´å‰Šé™¤æ©Ÿèƒ½ | [å±¥æ­´å‰Šé™¤æ©Ÿèƒ½_è©³ç´°è¨­è¨ˆæ›¸.md](./å±¥æ­´å‰Šé™¤æ©Ÿèƒ½_è©³ç´°è¨­è¨ˆæ›¸.md) | `clear-history`ã‚³ãƒãƒ³ãƒ‰ |
| DBãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | [db-migration-v2](../db-migration-v2/README.md) | ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ç®¡ç† |

---

## å¤‰æ›´å±¥æ­´

| æ—¥ä»˜ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | å¤‰æ›´å†…å®¹ | æ‹…å½“è€… |
|:---|:---|:---|:---|
| 2026-01-11 | 1.0.0 | åˆç‰ˆä½œæˆ | detailed-design-writer |
