# ループ履歴保存 バックエンド設計書

## 1. 修正対象関数

### 1.1 概要

`src/cli/handlers.rs`の`play_handler`関数を修正し、履歴保存処理を再生処理の前に移動する。

### 1.2 現在の実装（v1.0）

```rust
// src/cli/handlers.rs (L18-99)
pub fn play_handler(args: PlayArgs) -> Result<()> {
    // 1. 引数の検証とMML取得
    let (mml_string, should_save) = match (&args.mml, args.history_id) {
        (Some(mml), None) => (mml.clone(), true),
        (None, Some(id)) => {
            let db = db::Database::init()?;
            let entry = db.get_by_id(id)?;
            (entry.mml, false)  // ← 履歴ID再生時はshould_save=false
        }
        (None, None) => bail!("[CLI-E001] MML文字列または --history-id のいずれか一方を指定してください"),
        (Some(_), Some(_)) => unreachable!("clap should prevent this")
    };

    // 2. MML解析
    let ast = mml::parse(&mml_string)?;

    // 3. 音声合成
    let mut synth = audio::synthesizer::Synthesizer::new(/* ... */);
    let buffer = synth.synthesize(&ast)?;

    // 4. 再生
    match audio::player::AudioPlayer::new() {
        Ok(mut player) => {
            player.play(&buffer, args.loop_play)?;  // ← ループ時は無限ループ
            output::display_play_progress(&mml_string, &buffer, args.loop_play)?;
        }
        Err(_) => {
            eprintln!("Warning: Audio device not found. Skipping playback.");
        }
    }

    // 5. 履歴保存（新規入力かつ再生成功時）
    // ❌ 問題: ループ再生時は到達不可能
    if should_save {
        let db = db::Database::init()?;
        let entry = db::HistoryEntry::new(/* ... */);
        let history_id = db.save(&entry)?;
        output::success(&format!("✓ 再生完了（履歴ID: {history_id}）"));
    } else {
        output::success("✓ 再生完了");
    }

    Ok(())
}
```

**問題点**: 
- ステップ4で`player.play(&buffer, args.loop_play)`を呼び出すと、`args.loop_play=true`の場合は無限ループに入る
- ステップ5の履歴保存処理に到達できない

## 2. 修正後の実装（v2.0）

### 2.1 擬似コード

```rust
// src/cli/handlers.rs (L18-99) - 修正版
pub fn play_handler(args: PlayArgs) -> Result<()> {
    // 1. 引数の検証とMML取得
    let (mml_string, should_save) = match (&args.mml, args.history_id) {
        (Some(mml), None) => (mml.clone(), true),
        (None, Some(id)) => {
            let db = db::Database::init()?;
            let entry = db.get_by_id(id)?;
            (entry.mml, false)
        }
        (None, None) => bail!("[CLI-E001] ..."),
        (Some(_), Some(_)) => unreachable!()
    };

    // 2. MML解析
    let ast = mml::parse(&mml_string)?;

    // 3. 音声合成
    let mut synth = audio::synthesizer::Synthesizer::new(/* ... */);
    let buffer = synth.synthesize(&ast)?;

    // ✅ 4. 履歴保存（ループ前に実行）
    let history_id_opt = if should_save {
        let db = db::Database::init()?;
        let db_waveform = match args.waveform {
            Waveform::Sine => db::history::Waveform::Sine,
            Waveform::Sawtooth => db::history::Waveform::Sawtooth,
            Waveform::Square => db::history::Waveform::Square,
        };
        
        #[allow(clippy::cast_possible_truncation)]
        let bpm_u16 = args.bpm as u16;
        
        let entry = db::HistoryEntry::new(
            mml_string.clone(),
            db_waveform,
            args.volume,
            bpm_u16
        );
        
        match db.save(&entry) {
            Ok(id) => Some(id),
            Err(e) => {
                eprintln!("Warning: 履歴の保存に失敗しました: {}", e);
                None
            }
        }
    } else {
        None
    };

    // 5. 再生（ループ時は無限ループ）
    match audio::player::AudioPlayer::new() {
        Ok(mut player) => {
            player.play(&buffer, args.loop_play)?;
            output::display_play_progress(&mml_string, &buffer, args.loop_play)?;
        }
        Err(_) => {
            eprintln!("Warning: Audio device not found. Skipping playback.");
        }
    }

    // 6. 成功メッセージ表示
    if let Some(id) = history_id_opt {
        output::success(&format!("✓ 再生完了（履歴ID: {id}）"));
    } else {
        output::success("✓ 再生完了");
    }

    Ok(())
}
```

### 2.2 主要な変更点

| 項目 | 変更前（v1.0） | 変更後（v2.0） |
|------|--------------|--------------|
| 履歴保存タイミング | 再生後（L76-96） | 再生前（L60-75の間） |
| 履歴保存失敗時の処理 | エラー伝播（`?`） | 警告表示して継続 |
| 履歴IDの扱い | ローカル変数 | `Option<i64>`で保持 |
| 成功メッセージ | 履歴保存時のみ | 常に表示（履歴IDは任意） |

## 3. 処理詳細

### 3.1 should_saveフラグの判定ロジック

```rust
let (mml_string, should_save) = match (&args.mml, args.history_id) {
    (Some(mml), None) => (mml.clone(), true),        // ← 新規MML入力
    (None, Some(id)) => {
        let db = db::Database::init()?;
        let entry = db.get_by_id(id)?;
        (entry.mml, false)                            // ← 履歴ID再生
    }
    (None, None) => bail!("[CLI-E001] ..."),
    (Some(_), Some(_)) => unreachable!()
};
```

| ケース | `args.mml` | `args.history_id` | `should_save` | 説明 |
|--------|-----------|------------------|--------------|------|
| 1 | Some("CDE") | None | `true` | 新規MML入力 → 保存 |
| 2 | None | Some(42) | `false` | 履歴ID再生 → 保存しない |
| 3 | None | None | - | エラー（clap検証済み） |
| 4 | Some("CDE") | Some(42) | - | エラー（clap検証済み） |

### 3.2 履歴保存処理（詳細）

```rust
let history_id_opt = if should_save {
    // (1) DB接続確立
    let db = db::Database::init()?;
    
    // (2) 波形タイプ変換
    let db_waveform = match args.waveform {
        Waveform::Sine => db::history::Waveform::Sine,
        Waveform::Sawtooth => db::history::Waveform::Sawtooth,
        Waveform::Square => db::history::Waveform::Square,
    };
    
    // (3) BPM型変換（u32 -> u16）
    #[allow(clippy::cast_possible_truncation)]
    let bpm_u16 = args.bpm as u16;
    
    // (4) 履歴エントリ作成
    let entry = db::HistoryEntry::new(
        mml_string.clone(),
        db_waveform,
        args.volume,
        bpm_u16
    );
    
    // (5) DB保存（失敗時は警告表示）
    match db.save(&entry) {
        Ok(id) => Some(id),
        Err(e) => {
            eprintln!("Warning: 履歴の保存に失敗しました: {}", e);
            None
        }
    }
} else {
    None
};
```

**重要**: `db.save()`が失敗しても`Ok(None)`を返し、再生処理を継続する。

### 3.3 エラーハンドリング

| エラー条件 | 対処 | ユーザー影響 |
|-----------|------|-------------|
| DB接続失敗 | 警告表示、再生継続 | 履歴は保存されないが再生は可能 |
| INSERT失敗 | 警告表示、再生継続 | 履歴は保存されないが再生は可能 |
| 履歴ID取得失敗 | 警告表示、再生継続 | 履歴は保存されないが再生は可能 |

## 4. データベース統合

### 4.1 使用するDB API

| メソッド | 役割 | 引数 | 戻り値 |
|---------|------|------|--------|
| `Database::init()` | DB接続確立 | なし | `Result<Database>` |
| `db.save(&entry)` | 履歴保存 | `&HistoryEntry` | `Result<i64>` |
| `db.get_by_id(id)` | 履歴取得 | `i64` | `Result<HistoryEntry>` |

### 4.2 HistoryEntry構造体

```rust
pub struct HistoryEntry {
    pub id: Option<i64>,
    pub mml: String,
    pub waveform: Waveform,
    pub volume: f32,
    pub bpm: u16,
    pub created_at: DateTime<Utc>,
}

impl HistoryEntry {
    pub fn new(
        mml: String,
        waveform: Waveform,
        volume: f32,
        bpm: u16
    ) -> Self {
        Self {
            id: None,
            mml,
            waveform,
            volume,
            bpm,
            created_at: Utc::now(),
        }
    }
}
```

### 4.3 トランザクション

- rusqliteはデフォルトで自動コミット
- `db.save()`内でトランザクションを管理
- 失敗時は自動ロールバック

## 5. コード差分（概念的表現）

```diff
// src/cli/handlers.rs
pub fn play_handler(args: PlayArgs) -> Result<()> {
    // ... (引数検証、MML解析、音声合成)
    
-   // 4. 再生
+   // 4. 履歴保存（ループ前に実行）
+   let history_id_opt = if should_save {
+       let db = db::Database::init()?;
+       // ... (履歴エントリ作成)
+       match db.save(&entry) {
+           Ok(id) => Some(id),
+           Err(e) => {
+               eprintln!("Warning: 履歴の保存に失敗しました: {}", e);
+               None
+           }
+       }
+   } else {
+       None
+   };
+
+   // 5. 再生
    match audio::player::AudioPlayer::new() {
        Ok(mut player) => {
            player.play(&buffer, args.loop_play)?;
            // ...
        }
        Err(_) => { /* ... */ }
    }
    
-   // 5. 履歴保存（新規入力かつ再生成功時）
-   if should_save {
-       let db = db::Database::init()?;
-       // ... (履歴保存処理)
-       output::success(&format!("✓ 再生完了（履歴ID: {history_id}）"));
-   } else {
-       output::success("✓ 再生完了");
-   }
+   // 6. 成功メッセージ表示
+   if let Some(id) = history_id_opt {
+       output::success(&format!("✓ 再生完了（履歴ID: {id}）"));
+   } else {
+       output::success("✓ 再生完了");
+   }
    
    Ok(())
}
```

## 6. テスト仕様

### 6.1 ユニットテスト

#### Test 1: ループ再生時の履歴保存

```rust
#[test]
fn test_play_handler_loop_saves_history() {
    let db = db::Database::open_in_memory().unwrap();
    
    let args = PlayArgs {
        mml: Some("CDEFGAB".to_string()),
        history_id: None,
        waveform: Waveform::Sine,
        volume: 0.5,
        bpm: 120,
        loop_play: true,  // ← ループ有効
        metronome: false,
    };
    
    // タイムアウト付き実行（無限ループ対策）
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_secs(2));
        std::process::exit(0); // テスト終了
    });
    
    let result = play_handler(args);
    
    // 履歴が保存されているか確認
    let history = db.list(Some(1)).unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0].mml, "CDEFGAB");
}
```

#### Test 2: 非ループ再生時の履歴保存

```rust
#[test]
fn test_play_handler_non_loop_saves_history() {
    let db = db::Database::open_in_memory().unwrap();
    
    let args = PlayArgs {
        mml: Some("CDE".to_string()),
        history_id: None,
        waveform: Waveform::Sine,
        volume: 0.5,
        bpm: 120,
        loop_play: false,  // ← ループ無効
        metronome: false,
    };
    
    let result = play_handler(args);
    
    // 履歴が保存されているか確認
    let history = db.list(Some(1)).unwrap();
    assert_eq!(history.len(), 1);
    assert_eq!(history[0].mml, "CDE");
}
```

#### Test 3: 履歴ID再生時は保存しない

```rust
#[test]
fn test_play_handler_history_id_does_not_save() {
    let db = db::Database::open_in_memory().unwrap();
    
    // 事前に履歴を作成
    let entry = db::HistoryEntry::new("ABC".to_string(), db::Waveform::Sine, 0.5, 120);
    let saved_id = db.save(&entry).unwrap();
    
    let args = PlayArgs {
        mml: None,
        history_id: Some(saved_id),  // ← 履歴ID指定
        waveform: Waveform::Sine,
        volume: 0.5,
        bpm: 120,
        loop_play: true,
        metronome: false,
    };
    
    let result = play_handler(args);
    
    // 履歴が重複保存されていないか確認
    let history = db.list(None).unwrap();
    assert_eq!(history.len(), 1); // ← 1件のまま
}
```

### 6.2 統合テスト

| テストケース | 操作 | 期待結果 |
|------------|------|----------|
| IT-1 | `sine-mml play "CDE" --loop`実行後、2秒でCtrl+C | 履歴DBに"CDE"が保存されている |
| IT-2 | `sine-mml play --history-id 1 --loop`実行 | 重複保存されない |
| IT-3 | `sine-mml play "FGA"`実行 | 従来通り履歴が保存される |

### 6.3 回帰テスト

| テストケース | 目的 | 期待結果 |
|------------|------|----------|
| RT-1 | 非ループ再生の動作確認 | 履歴が正常に保存される |
| RT-2 | 履歴ID再生の動作確認 | 重複保存されない |
| RT-3 | DB保存失敗時の動作確認 | 警告表示後、再生が継続される |

## 7. パフォーマンス考慮事項

### 7.1 レイテンシ分析

| 処理 | 所要時間 | 備考 |
|------|---------|------|
| `Database::init()` | 5-10ms | SQLiteファイルオープン |
| `db.save(&entry)` | 10-30ms | INSERT + COMMIT |
| 合計追加レイテンシ | **15-40ms** | 目標50ms以内をクリア |

### 7.2 最適化ポイント

- DB接続は既存の`Database::init()`を使用（接続プール不要）
- トランザクションは`db.save()`内で自動管理
- 履歴保存失敗時はリトライしない（レイテンシ増加防止）

## 8. セキュリティ考慮事項

### 8.1 SQLインジェクション対策

```rust
// rusqliteのプレースホルダー（?）を使用
pub fn save(&self, entry: &HistoryEntry) -> Result<i64> {
    let mut stmt = self.conn.prepare(
        "INSERT INTO history (mml, waveform, volume, bpm, created_at) VALUES (?, ?, ?, ?, ?)"
    )?;
    stmt.execute(params![
        &entry.mml,  // ← ユーザー入力（プレースホルダーで安全）
        &entry.waveform.to_string(),
        &entry.volume,
        &entry.bpm,
        &entry.created_at.to_rfc3339()
    ])?;
    Ok(self.conn.last_insert_rowid())
}
```

### 8.2 ディスク容量枯渇対策

- 履歴保存失敗時、無限リトライしない
- ユーザーへ警告を表示し、対処を促す

## 9. 移行計画

### 9.1 後方互換性

- データベーススキーマ変更なし → マイグレーション不要
- CLI引数変更なし → ユーザースクリプトへの影響なし
- 既存の履歴データは互換性あり

### 9.2 デプロイ手順

1. `src/cli/handlers.rs`を修正
2. ユニットテストを実行（`cargo test`）
3. E2Eテストを実行（`tests/cli_integration.rs`）
4. ビルド（`cargo build --release`）
5. インストール（`cargo install --path .`）

### 9.3 ロールバック手順

1. Git履歴から修正前のコミットに戻す
2. 再ビルド・再インストール
3. 既存の履歴データは影響なし（スキーマ互換性あり）

---

## 変更履歴

| 日付 | バージョン | 変更内容 | 担当者 |
|:---|:---|:---|:---|
| 2026-01-11 | 1.0.0 | 初版作成 | Antigravity |
